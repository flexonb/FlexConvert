"use strict";

!function (e, t) {
   "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e.pdfjsWorker = {}))
}(this, function (e) {
   const t = "undefined" != typeof document && "undefined" != typeof CustomEvent && "function" == typeof CustomEvent;

   function n(e, n) {
      if (!t) return;
      const r = new CustomEvent("updatefromsandbox", {
         detail: {
            id: e,
            data: n
         }
      });
      document.dispatchEvent(r)
   }
   class r {
      constructor(e) {
         this.started = new Promise(t => {
            const n = e => {
               if ("init" !== e.data.type) return;
               globalThis.removeEventListener("message", n), this.port = e.ports[0], this.port.onmessage = e => {
                  this.callback && this.callback(e.data)
               }, t()
            };
            globalThis.addEventListener("message", n)
         })
      }
      send(e, t) {
         this.port.postMessage(e, t)
      }
      set onmessage(e) {
         this.callback = e
      }
   }
   class o {
      constructor(e) {
         this.listener = e, this.started = new Promise(e => {
            this.parent = new r(e)
         }), this.parent.onmessage = e => {
            this.listener(e)
         }
      }
      async send(e) {
         await this.started, this.parent.send(e)
      }
   }
   class i {
      constructor(e) {
         this.type = e, this.target = null, this.currentTarget = null
      }
      init(e, t, n) {
         this.target = e, this.currentTarget = t, this.detail = n
      }
   }
   class a {
      constructor() {
         this.listeners = Object.create(null)
      }
      on(e, t, n = null) {
         const r = this.listeners;
         e in r || (r[e] = []), r[e].push({
            listener: t,
            capture: !1
         })
      }
      off(e, t, n = null) {
         const r = this.listeners,
            o = r[e];
         if (!o) return;
         const i = o.findIndex(e => e.listener === t && e.capture === !1);
         i > -1 && o.splice(i, 1)
      }
      dispatch(e) {
         const t = this.listeners[e.type];
         if (!t) return;
         const n = t.slice(0);
         for (const t of n) t.listener.call(this, e)
      }
   }
   class s {
      constructor() {
         this.url = null, this.baseUrl = null, this.items = [], this.itemsMap = new Map, this.fontRules = [], this.styleSheets = new Map, this.styleSheetsContent = new Map, this.images = new Map, this.imagesContent = new Map, this.id = "", this.pageNumber = 0, this.pageId = "", this.canvas = [], this.svgs = new Map, this.hasOwnCanvas = !1, this.media = ""
      }
      parse(e) {
         this.url = e.url, this.baseUrl = e.baseUrl, this.id = e.id, this.pageNumber = e.pageNumber, this.pageId = e.pageId, this.media = e.media, this.hasOwnCanvas = e.hasOwnCanvas;
         for (const t of e.canvas) this.canvas.push(t);
         for (const [e, t] of Object.entries(e.styleSheets)) this.styleSheets.set(e, t);
         for (const [e, t] of Object.entries(e.styleSheetsContent)) this.styleSheetsContent.set(e, t);
         for (const [e, t] of Object.entries(e.images)) this.images.set(e, t);
         for (const [e, t] of Object.entries(e.imagesContent)) this.imagesContent.set(e, t);
         for (const [e, t] of Object.entries(e.svgs)) this.svgs.set(e, t);
         for (const t of e.fontRules) this.fontRules.push(t);
         this.items = e.items, this.itemsMap = new Map;
         for (const t of this.items) this.itemsMap.set(t.id, t)
      }
      get(e) {
         return this.itemsMap.get(e)
      }
   }
   class c {
      constructor(e, t, n) {
         this.id = e, this.page = t, this.parent = n, this.children = [], this.element = null, this.text = null, this.attributes = Object.create(null), this.styles = Object.create(null), this.isSvg = !1, this.isCanvas = !1, this.isImage = !1, this.isStyle = !1, this.isText = !1, this.isIframe = !1, this.isLink = !1, this.isInput = !1, this.isFor = null, this.isTextNode = !1, this.checked = !1, this.value = null, this.type = null, this.name = null, this.classList = new Set, this.dataset = Object.create(null), this.style = new Proxy(this.styles, {
            set: (e, t, n) => (e[t] = n, !0)
         })
      }
      get ownerDocument() {
         return this.page
      }
      get defaultView() {
         return this.page
      }
      get documentElement() {
         return this.page.items[0]
      }
      get body() {
         return this.page.get("body")
      }
      get head() {
         return this.page.get("head")
      }
      get parentNode() {
         return this.parent
      }
      get nextSibling() {
         if (!this.parent) return null;
         const e = this.parent.children.indexOf(this);
         return this.parent.children[e + 1] || null
      }
      get previousSibling() {
         if (!this.parent) return null;
         const e = this.parent.children.indexOf(this);
         return this.parent.children[e - 1] || null
      }
      get firstChild() {
         return this.children[0] || null
      }
      get lastChild() {
         return this.children.at(-1) || null
      }
      get childNodes() {
         return this.children
      }
      get nodeName() {
         return this.element
      }
      get nodeType() {
         return this.isTextNode ? 3 : 1
      }
      get textContent() {
         return this.text
      }
      set textContent(e) {
         this.text = e
      }
      get clientWidth() {
         return this.attributes.width || 0
      }
      get clientHeight() {
         return this.attributes.height || 0
      }
      get src() {
         return this.attributes.src
      }
      get href() {
         return this.attributes.href
      }
      get localName() {
         return this.element
      }
      get tagName() {
         return this.element
      }
      appendChild(e) {
         this.children.push(e)
      }
      setAttribute(e, t) {
         this.attributes[e] = t
      }
      getAttribute(e) {
         return this.attributes[e]
      }
      hasAttribute(e) {
         return e in this.attributes
      }
      removeAttribute(e) {
         delete this.attributes[e]
      }
      querySelector(e) {
         if ("#" === e[0]) {
            const t = e.substring(1);
            return this.page.get(t)
         }
         return null
      }
      querySelectorAll(e) {
         return []
      }
      getElementById(e) {
         return this.page.get(e)
      }
      getElementsByTagName(e) {
         const t = [];
         for (const n of this.page.items) n.element === e && t.push(n);
         return t
      }
      getElementsByClassName(e) {
         const t = [];
         for (const n of this.page.items) n.classList.has(e) && t.push(n);
         return t
      }
      getComputedStyle() {
         return this.styles
      }
      getBoundingClientRect() {
         return {
            x: 0,
            y: 0,
            width: this.attributes.width || 0,
            height: this.attributes.height || 0,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
         }
      }
      createEvent(e) {
         return new i(e)
      }
      dispatchEvent(e) {}
      addEventListener(e, t, n) {}
      removeEventListener(e, t, n) {}
      getMatchedCSSRules() {
         return []
      }
      createDocumentFragment() {
         return new c("fragment", this.page, null)
      }
      createElementNS(e, t) {
         const n = new c(t, this.page, null);
         return "http://www.w3.org/2000/svg" === e && (n.isSvg = !0), n
      }
      createElement(e) {
         return this.createElementNS(null, e)
      }
      createTextNode(e) {
         const t = new c("#text", this.page, null);
         return t.isTextNode = !0, t.textContent = e, t
      }
      cloneNode(e) {
         const t = new c(this.element, this.page, this.parent);
         if (t.attributes = { ...this.attributes
            }, t.styles = { ...this.styles
            }, t.classList = new Set(this.classList), t.dataset = { ...this.dataset
            }, t.isSvg = this.isSvg, t.isCanvas = this.isCanvas, t.isImage = this.isImage, t.isStyle = this.isStyle, t.isText = this.isText, t.isIframe = this.isIframe, t.isLink = this.isLink, t.isInput = this.isInput, t.isFor = this.isFor, t.isTextNode = this.isTextNode, t.checked = this.checked, t.value = this.value, t.type = this.type, t.name = this.name, t.text = this.text, e)
            for (const n of this.children) t.appendChild(n.cloneNode(e));
         return t
      }
   }
   class l extends a {
      constructor() {
         super(), this.page = new s, this.document = new c("document", this.page, null), this.parser = new DOMParser, this.window = this.document, this.navigator = {
            userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36"
         }, this.MutationObserver = class {
            constructor(e) {}
            observe(e, t) {}
            disconnect() {}
         }, this.matchMedia = e => ({
            matches: e === this.page.media,
            media: e,
            onchange: null,
            addListener: () => {},
            removeListener: () => {},
            addEventListener: () => {},
            removeEventListener: () => {},
            dispatchEvent: () => {}
         })
      }
      parse(e) {
         this.page.parse(e);
         const t = this.page.items,
            n = this.page.itemsMap;
         for (const e of t) {
            const t = n.get(e.id);
            t.element = e.element, t.isSvg = e.isSvg, t.isCanvas = e.isCanvas, t.isImage = e.isImage, t.isStyle = e.isStyle, t.isText = e.isText, t.isIframe = e.isIframe, t.isLink = e.isLink, t.isInput = e.isInput, t.isFor = e.isFor, t.isTextNode = e.isTextNode, t.checked = e.checked, t.value = e.value, t.type = e.type, t.name = e.name, t.text = e.text;
            for (const [n, r] of Object.entries(e.attributes)) t.attributes[n] = r;
            for (const [n, r] of Object.entries(e.styles)) t.styles[n] = r;
            for (const n of e.classList) t.classList.add(n);
            for (const [n, r] of Object.entries(e.dataset)) t.dataset[n] = r
         }
         for (const e of t) {
            const t = n.get(e.id);
            if (e.parent) {
               const r = n.get(e.parent);
               t.parent = r, r.children.push(t)
            }
            if (e.children)
               for (const r of e.children) {
                  const e = n.get(r);
                  t.children.push(e)
               }
         }
      }
      get(e) {
         return this.page.get(e)
      }
      destroy() {
         this.page = null, this.document = null
      }
   }
   class u {
      constructor(e) {
         this.worker = e, this.Promise = Promise, this.messageHandler = new o(this.onMessage.bind(this)), this.objects = {}, this.callbacks = {}, this.lastCallbackId = 0
      }
      onMessage(e) {
         const {
            id: t,
            cId: n,
            name: r,
            isCmd: o,
            isPromise: a,
            isEvent: s,
            data: c
         } = e;
         if (o) switch (r) {
            case "eval":
               {
                  const e = new l;
                  e.parse(c), globalThis.window = e, globalThis.document = e.document, globalThis.navigator = e.navigator, globalThis.MutationObserver = e.MutationObserver, globalThis.matchMedia = e.matchMedia;
                  const t = new i("DOMContentLoaded");
                  e.dispatch(t);
                  break
               }
            case "import":
               importScripts(c);
               break;
            case "isnode":
               n(t, "undefined" == typeof window);
               break;
            case "ready":
               this.messageHandler.send({
                  id: t,
                  cId: n,
                  name: r,
                  isCmd: !0,
                  data: !0
               })
         } else s ? this.callbacks[n](c) : a ? this.callbacks[n](c) : this.objects[t][r](c)
      }
      createObj(e) {
         this.objects[e] = {}
      }
      destroyObj(e) {
         delete this.objects[e]
      }
      register(e, t) {
         this.objects[e.id][e.name] = t
      }
      unregister(e) {
         delete this.objects[e.id][e.name]
      }
      createCallbackId(e) {
         const t = "c" + this.lastCallbackId++;
         return this.callbacks[t] = e, t
      }
      destroyCallbackId(e) {
         delete this.callbacks[e]
      }
   }
   class d {
      constructor(e, t) {
         this.id = e, this.transport = t
      }
      get(e) {
         return new this.transport.Promise(t => {
            const n = this.transport.createCallbackId(e => {
               t(e), this.transport.destroyCallbackId(n)
            });
            this.transport.messageHandler.send({
               id: this.id,
               cId: n,
               name: e,
               isPromise: !0
            })
         })
      }
      set(e, t) {
         this.transport.messageHandler.send({
            id: this.id,
            name: e,
            data: t
         })
      }
      call(e, t) {
         this.transport.messageHandler.send({
            id: this.id,
            name: e,
            data: t
         })
      }
      callWithCallback(e, t, n) {
         const r = this.transport.createCallbackId(e => {
            n(e), this.transport.destroyCallbackId(r)
         });
         this.transport.messageHandler.send({
            id: this.id,
            cId: r,
            name: e,
            data: t
         })
      }
      callWithPromise(e, t) {
         return new this.transport.Promise(n => {
            const r = this.transport.createCallbackId(e => {
               n(e), this.transport.destroyCallbackId(r)
            });
            this.transport.messageHandler.send({
               id: this.id,
               cId: r,
               name: e,
               isPromise: !0,
               data: t
            })
         })
      }
      addEventListener(e, t) {
         const n = this.transport.createCallbackId(e => {
            t(e)
         });
         this.transport.messageHandler.send({
            id: this.id,
            cId: n,
            name: e,
            isEvent: !0
         })
      }
   }
   class h {
      constructor(e, t) {
         this.nativeData = e, this.handler = t, this.transport = new u(this), this.eventHandler = new d("eventHandler", this.transport), this.setup()
      }
      setup() {
         this.transport.createObj("pdfjs"), this.transport.createObj("pdfjs-viewer"), this.transport.register({
            id: "pdfjs",
            name: "test"
         }, this.test.bind(this)), this.transport.register({
            id: "pdfjs-viewer",
            name: "test"
         }, this.test.bind(this))
      }
      test(e) {
         this.eventHandler.call("test", e)
      }
      destroy() {
         this.transport.destroyObj("pdfjs"), this.transport.destroyObj("pdfjs-viewer")
      }
   }
   class p {
      constructor(e, t, n) {
         this.messageHandler = e, this.source = t, this.nativeData = n, this.lastPromiseId = 0, this.promises = {}, this.setup()
      }
      setup() {
         this.messageHandler.on("document", this.onDocument.bind(this)), this.messageHandler.on("page", this.onPage.bind(this)), this.messageHandler.on("scale", this.onScale.bind(this)), this.messageHandler.on("viewport", this.onViewport.bind(this)), this.messageHandler.on("cleanup", this.onCleanup.bind(this)), this.messageHandler.on("render", this.onRender.bind(this)), this.messageHandler.on("textlayer", this.onTextLayer.bind(this)), this.messageHandler.on("annotationlayer", this.onAnnotationLayer.bind(this)), this.messageHandler.on("svg", this.onSVG.bind(this)), this.messageHandler.on("cancel", this.onCancel.bind(this)), this.messageHandler.on("promise", this.onPromise.bind(this))
      }
      onDocument(e) {
         this.nativeData.pdfDocument = e
      }
      onPage(e) {
         this.nativeData.pdfPage = e
      }
      onScale(e) {
         this.nativeData.scale = e
      }
      onViewport(e) {
         this.nativeData.viewport = e
      }
      onCleanup() {
         this.nativeData.pdfDocument.cleanup(), this.nativeData.pdfDocument.destroy()
      }
      onRender(e) {
         const t = this.nativeData.pdfPage,
            n = this.nativeData.viewport,
            r = {
               canvasContext: e.context,
               viewport: n,
               intent: e.intent,
               paintSolidColors: !0,
               optionalContentConfigPromise: this.nativeData.optionalContentConfigPromise
            };
         t.render(r)
      }
      onTextLayer(e) {
         const t = this.nativeData.pdfPage,
            n = this.nativeData.viewport;
         t.streamTextContent({
            includeMarkedContent: !0,
            disableNormalization: !0
         }).then(r => {
            const o = new ReadableStream({
               start(e) {
                  r.on("data", t => {
                     e.enqueue(t)
                  }), r.on("end", () => {
                     e.close()
                  })
               }
            });
            this.messageHandler.send("textlayer", {
               id: e,
               stream: o
            }, [o])
         })
      }
      onAnnotationLayer(e) {
         this.nativeData.pdfPage.getAnnotations({
            intent: e.intent
         }).then(t => {
            this.messageHandler.send("annotationlayer", {
               id: e.id,
               annotations: t
            })
         })
      }
      onSVG(e) {
         const t = this.nativeData.pdfPage,
            n = this.nativeData.fontRules;
         t.getOperatorList({
            fontRules: n
         }).then(n => t.getSVG(n, this.nativeData.viewport)).then(t => {
            this.messageHandler.send("svg", {
               id: e,
               svg: t
            })
         })
      }
      onCancel(e) {
         this.nativeData.pdfDocument.cancel()
      }
      onPromise(e) {
         const t = this.lastPromiseId++,
            n = this.promises[t] = this.nativeData.pdfDocument.getPromise(e.name, e.data);
         n.then(n => {
            this.messageHandler.send("promise", {
               id: e.id,
               promiseId: t,
               data: n,
               isResolved: !0
            }), delete this.promises[t]
         }).catch(n => {
            this.messageHandler.send("promise", {
               id: e.id,
               promiseId: t,
               data: n,
               isResolved: !1
            }), delete this.promises[t]
         })
      }
   }
   class f {
      constructor(e, t) {
         this.handler = e, this.transport = new u(this), this.eventHandler = new d("eventHandler", this.transport), this.nativeData = {
            pdfDocument: null,
            pdfPage: null,
            optionalContentConfigPromise: null,
            scale: 1,
            viewport: null,
            fontRules: []
         }, this.pdfManager = new p(this.handler, this, this.nativeData), this.setup()
      }
      setup() {
         this.transport.createObj("pdfjs"), this.transport.register({
            id: "pdfjs",
            name: "document"
         }, this.loadDocument.bind(this))
      }
      destroy() {
         this.transport.destroyObj("pdfjs")
      }
      loadDocument(e) {
         const t = this.handler.api,
            r = {
               nativeData: this.nativeData,
               pdfManager: this.pdfManager,
               messageHandler: this.handler,
               eventHandler: this.eventHandler
            };
         t.getDocument({ ...e,
            source: { ...e.source,
               manager: r
            }
         }).promise.then(e => {
            this.nativeData.pdfDocument = e, this.nativeData.optionalContentConfigPromise = e.getOptionalContentConfig(), this.handler.send("document", {
               id: e.id,
               numPages: e.numPages,
               fingerprint: e.fingerprint,
               transportId: e.transport.id
            })
         })
      }
   }
   class m {
      constructor(e) {
         this.handler = e, this.api = null, this.verbose = !1, this.setup()
      }
      setup() {
         const e = this.handler.createCallbackId(e => {
            this.handler.destroyCallbackId(e), this.init(e)
         });
         this.handler.messageHandler.send({
            id: "pdfjs",
            cId: e,
            name: "get",
            isPromise: !0
         })
      }
      init(e) {
         this.api = e, this.handler.messageHandler.on("document", this.onDocument.bind(this)), this.handler.messageHandler.on("page", this.onPage.bind(this)), this.handler.messageHandler.on("render", this.onRender.bind(this)), this.handler.messageHandler.on("textlayer", this.onTextLayer.bind(this)), this.handler.messageHandler.on("annotationlayer", this.onAnnotationLayer.bind(this)), this.handler.messageHandler.on("svg", this.onSVG.bind(this)), this.handler.messageHandler.on("cancel", this.onCancel.bind(this)), this.handler.messageHandler.on("promise", this.onPromise.bind(this))
      }
      onDocument(e) {
         const t = new d(e.transportId, this.handler);
         this.api.onDocument(e.id, {
            numPages: e.numPages,
            fingerprint: e.fingerprint,
            transport: t
         })
      }
      onPage(e) {
         this.api.onPage(e.id, e.pageIndex, e.pageInfo)
      }
      onRender(e) {
         this.api.onRender(e.id, e.context, e.intent)
      }
      onTextLayer(e) {
         this.api.onTextLayer(e.id, e.stream)
      }
      onAnnotationLayer(e) {
         this.api.onAnnotationLayer(e.id, e.annotations)
      }
      onSVG(e) {
         this.api.onSVG(e.id, e.svg)
      }
      onCancel(e) {
         this.api.onCancel(e.id)
      }
      onPromise(e) {
         this.api.onPromise(e.id, e.promiseId, e.isResolved, e.data)
      }
   }
   class g {
      constructor(e) {
         this.transport = new u(this), this.pdfManager = new m(this.transport), this.pdfjsWrapper = new h(null, this)
      }
      get api() {
         return this.pdfManager.api
      }
      get objects() {
         return this.transport.objects
      }
      createObj(e) {
         this.transport.createObj(e)
      }
      destroyObj(e) {
         this.transport.destroyObj(e)
      }
      register(e, t) {
         this.transport.register(e, t)
      }
      send(e, t, n) {
         this.transport.messageHandler.send({
            name: e,
            data: t
         }, n)
      }
   }
   class b {
      constructor(e) {
         this.name = e, this.pdfjs = null, this.pdfjsWrapper = null, this.pdfManager = null, this.messageHandler = new o(this.onMessage.bind(this)), this.isReady = !1, this.isNode = !1, this.setup()
      }
      async setup() {
         await this.messageHandler.started;
         const e = await this.messageHandler.sendWithPromise("isnode");
         this.isNode = e, this.pdfjsWrapper = new g(this), this.pdfManager = this.pdfjsWrapper.pdfManager, this.messageHandler.send("ready").then(() => {
            this.isReady = !0
         })
      }
      onMessage(e) {
         const {
            isCmd: t,
            name: n
         } = e;
         t && "eval" === n ? this.pdfjsWrapper.pdfjsWrapper.transport.onMessage(e) : this.pdfjsWrapper.transport.onMessage(e)
      }
   }
   class y {
      constructor(e) {
         this.name = e, this.port = null, this.pdfjs = null, this.pdfjsWrapper = null, this.pdfManager = null, this.isReady = !1, this.isNode = !1, this.setup()
      }
      async setup() {
         const e = new MessageChannel;
         this.port = e.port1;
         const t = {
            type: "init",
            name: this.name,
            port: e.port2
         };
         this.worker.postMessage(t, [e.port2]), this.port.onmessage = this.onMessage.bind(this)
      }
      onMessage(e) {
         const {
            isCmd: t,
            name: n
         } = e.data;
         t && "ready" === n ? this.isReady = !0 : this.pdfjsWrapper.transport.onMessage(e.data)
      }
   }
   class v {
      constructor(e, t, n) {
         this.name = e, this.worker = t, this.pdfjs = n, this.isReady = !1, this.isNode = !1, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         this.worker.isNode = this.isNode, this.pdfjsWrapper = new f(this), this.pdfManager = this.pdfjsWrapper.pdfManager, this.isReady = !0
      }
      onMessage(e) {
         this.pdfjsWrapper.transport.onMessage(e)
      }
      send(e, t, n) {
         this.worker.onmessage({
            data: {
               name: e,
               data: t
            }
         }, n)
      }
   }
   class w {
      constructor(e) {
         this.name = e, this.worker = null, this.isReady = !1, this.isNode = !1, this.pdfjs = null, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         this.worker = new b(this.name), this.pdfjsWrapper = this.worker.pdfjsWrapper, this.pdfManager = this.worker.pdfManager
      }
      get objects() {
         return this.worker.pdfjsWrapper.objects
      }
      get api() {
         return this.pdfManager.api
      }
      createObj(e) {
         this.worker.pdfjsWrapper.createObj(e)
      }
      destroyObj(e) {
         this.worker.pdfjsWrapper.destroyObj(e)
      }
      register(e, t) {
         this.worker.pdfjsWrapper.register(e, t)
      }
   }
   const S = {
      workerSrc: ""
   };
   class k {
      constructor(e, t, n) {
         this.name = e, this.worker = null, this.pdfjs = t, this.workerOptions = n, this.isReady = !1, this.isNode = !1, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         const e = this.workerOptions.workerSrc || S.workerSrc;
         this.worker = new Worker(e), this.worker.onmessage = this.onMessage.bind(this), this.pdfjsWrapper = new y(this.name), this.pdfjsWrapper.worker = this.worker, this.pdfjsWrapper.setup(), this.pdfManager = this.pdfjsWrapper.pdfManager
      }
      onMessage(e) {
         this.pdfjsWrapper.onMessage(e)
      }
      get objects() {
         return this.pdfjsWrapper.objects
      }
      get api() {
         return this.pdfManager.api
      }
      createObj(e) {
         this.pdfjsWrapper.createObj(e)
      }
      destroyObj(e) {
         this.pdfjsWrapper.destroyObj(e)
      }
      register(e, t) {
         this.pdfjsWrapper.register(e, t)
      }
   }
   class P {
      constructor(e, t, n) {
         this.name = e, this.worker = null, this.pdfjs = t, this.workerOptions = n, this.isReady = !1, this.isNode = !1, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         this.worker = new v(this.name, this, this.pdfjs), this.pdfjsWrapper = this.worker.pdfjsWrapper, this.pdfManager = this.worker.pdfManager
      }
      onmessage(e, t) {
         this.worker.onMessage(e.data)
      }
      get objects() {
         return this.pdfjsWrapper.objects
      }
      get api() {
         return this.pdfManager.api
      }
      createObj(e) {
         this.pdfjsWrapper.createObj(e)
      }
      destroyObj(e) {
         this.pdfjsWrapper.destroyObj(e)
      }
      register(e, t) {
         this.pdfjsWrapper.register(e, t)
      }
   }
   class I {
      constructor(e, t, n) {
         this.messageHandler = e, this.source = t, this.nativeData = n, this.lastPromiseId = 0, this.promises = {}, this.setup()
      }
      setup() {
         this.messageHandler.on("document", this.onDocument.bind(this))
      }
      onDocument(e) {
         this.nativeData.pdfDocument = e
      }
   }
   class D {
      constructor(e, t) {
         this.handler = e, this.transport = new u(this), this.eventHandler = new d("eventHandler", this.transport), this.nativeData = {
            pdfDocument: null
         }, this.pdfManager = new I(this.handler, this, this.nativeData), this.setup()
      }
      setup() {
         this.transport.createObj("pdfjs"), this.transport.register({
            id: "pdfjs",
            name: "document"
         }, this.loadDocument.bind(this))
      }
      destroy() {
         this.transport.destroyObj("pdfjs")
      }
      loadDocument(e) {
         const t = this.handler.api,
            n = {
               nativeData: this.nativeData,
               pdfManager: this.pdfManager,
               messageHandler: this.handler,
               eventHandler: this.eventHandler
            };
         t.getDocument({ ...e,
            source: { ...e.source,
               manager: n
            }
         }).promise.then(e => {
            this.nativeData.pdfDocument = e, this.handler.send("document", {
               id: e.id,
               numPages: e.numPages,
               fingerprint: e.fingerprint,
               transportId: e.transport.id
            })
         })
      }
   }
   class O {
      constructor(e) {
         this.handler = e, this.api = null, this.verbose = !1, this.setup()
      }
      setup() {
         const e = this.handler.createCallbackId(e => {
            this.handler.destroyCallbackId(e), this.init(e)
         });
         this.handler.messageHandler.send({
            id: "pdfjs",
            cId: e,
            name: "get",
            isPromise: !0
         })
      }
      init(e) {
         this.api = e, this.handler.messageHandler.on("document", this.onDocument.bind(this))
      }
      onDocument(e) {
         const t = new d(e.transportId, this.handler);
         this.api.onDocument(e.id, {
            numPages: e.numPages,
            fingerprint: e.fingerprint,
            transport: t
         })
      }
   }
   class T {
      constructor(e) {
         this.transport = new u(this), this.pdfManager = new O(this.transport), this.pdfjsWrapper = new D(this)
      }
      get api() {
         return this.pdfManager.api
      }
      get objects() {
         return this.transport.objects
      }
      createObj(e) {
         this.transport.createObj(e)
      }
      destroyObj(e) {
         this.transport.destroyObj(e)
      }
      register(e, t) {
         this.transport.register(e, t)
      }
      send(e, t, n) {
         this.transport.messageHandler.send({
            name: e,
            data: t
         }, n)
      }
   }
   class x {
      constructor(e) {
         this.name = e, this.worker = null, this.isReady = !1, this.isNode = !1, this.pdfjs = null, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         this.worker = new b(this.name), this.pdfjsWrapper = new T(this), this.pdfManager = this.pdfjsWrapper.pdfManager
      }
      get objects() {
         return this.worker.pdfjsWrapper.objects
      }
      get api() {
         return this.pdfManager.api
      }
      createObj(e) {
         this.worker.pdfjsWrapper.createObj(e)
      }
      destroyObj(e) {
         this.worker.pdfjsWrapper.destroyObj(e)
      }
      register(e, t) {
         this.worker.pdfjsWrapper.register(e, t)
      }
   }
   const L = {
      workerSrc: ""
   };
   class C {
      constructor(e, t, n) {
         this.name = e, this.worker = null, this.pdfjs = t, this.workerOptions = n, this.isReady = !1, this.isNode = !1, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         const e = this.workerOptions.workerSrc || L.workerSrc;
         this.worker = new Worker(e), this.worker.onmessage = this.onMessage.bind(this), this.pdfjsWrapper = new y(this.name), this.pdfjsWrapper.worker = this.worker, this.pdfjsWrapper.setup(), this.pdfManager = this.pdfjsWrapper.pdfManager
      }
      onMessage(e) {
         this.pdfjsWrapper.onMessage(e)
      }
      get objects() {
         return this.pdfjsWrapper.objects
      }
      get api() {
         return this.pdfManager.api
      }
      createObj(e) {
         this.pdfjsWrapper.createObj(e)
      }
      destroyObj(e) {
         this.pdfjsWrapper.destroyObj(e)
      }
      register(e, t) {
         this.pdfjsWrapper.register(e, t)
      }
   }
   class M {
      constructor(e, t, n) {
         this.name = e, this.worker = null, this.pdfjs = t, this.workerOptions = n, this.isReady = !1, this.isNode = !1, this.pdfjsWrapper = null, this.pdfManager = null, this.setup()
      }
      async setup() {
         this.worker = new v(this.name, this, this.pdfjs), this.pdfjsWrapper = this.worker.pdfjsWrapper, this.pdfManager = this.worker.pdfManager
      }
      onmessage(e, t) {
         this.worker.onMessage(e.data)
      }
      get objects() {
         return this.pdfjsWrapper.objects
      }
      get api() {
         return this.pdfManager.api
      }
      createObj(e) {
         this.pdfjsWrapper.createObj(e)
      }
      destroyObj(e) {
         this.pdfjsWrapper.destroyObj(e)
      }
      register(e, t) {
         this.pdfjsWrapper.register(e, t)
      }
   }
   const A = {
      createSandbox(e = !1) {
         return e ? new x("sandbox") : new w("sandbox")
      },
      createWorker(e, t) {
         return new k("worker", e, t)
      },
      createFakeWorker(e) {
         return new P("fakeworker", e)
      },
      createFakeSandbox(e) {
         return new M("fakesandbox", e)
      }
   };
   e.PDFWorker = class {
      constructor(e) {
         this.name = e, this.worker = null, this.setup()
      }
      setup() {
         this.worker = A.createSandbox("undefined" == typeof window)
      }
      message(e, t) {
         this.worker.objects[e.id][e.name](e.data)
      }
      load(e) {
         this.worker.pdfManager.api = e
      }
      destroy() {
         this.worker = null
      }
   }, e.WorkerMessageHandler = {
      setup(e, t) {
         const r = A.createSandbox("undefined" == typeof window);
         r.pdfManager.api = e, self.addEventListener("message", function (e) {
            const {
               id: o,
               name: i,
               data: a
            } = e.data;
            "eval" === i ? n(o, r.worker.pdfjsWrapper.transport.onMessage(e.data)) : r.objects[o][i](a)
         })
      }
   }
});
